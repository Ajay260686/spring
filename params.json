{"name":"Spring Notes","tagline":"spring , spring jdbc , spring data, jpa , hibernate","body":"### Dependency Injection\r\nContext Dependency Lookup(CDL) v/s Dependency Injection\r\nThe Dependency Pull code must actively obtain a reference to the registry and interact with it to obtain the\r\ndependencies, and using CDL requires your classes to implement a specific interface and look up all\r\ndependencies manually. When you are using injection, the most your classes have to do is allow\r\ndependencies to be injected using either constructors or setters.\r\n\r\nUsing injection, you are free to use your classes completely decoupled from the IoC container that is\r\nsupplying dependent objects with their collaborators manually, whereas with lookup, your classes are\r\nalways dependent on the classes and interfaces defined by the container. Another drawback with lookup\r\nis that it becomes very difficult to test your classes in isolation from the container. Using injection,\r\ntesting your components is trivial, because you can simply provide the dependencies yourself using the\r\nappropriate constructor or setter.\r\n\r\nThe biggest reason to choose injection over lookup is that it makes your\r\nlife easier. You write substantially less code when you are using injection, and the code that you do write\r\nis simple and can, in general, be automated by a good IDE. You will notice that all of the code in the\r\ninjection samples is passive, in that it doesn’t actively try to accomplish a task. The most exciting thing\r\nyou see in injection code is objects getting stored in a field only; no other codes were involved in pulling\r\nthe dependency from any registry or container. Therefore, the code is much simpler and less error\r\nprone. Passive code is much simpler to maintain than active code, because there is very little that can go\r\nwrong.\r\n\r\n### Constructor v/s Setter Injection ==\r\nConstructor Injection is particularly useful when you\r\nabsolutely must have an instance of the dependency class before your component is used. Many\r\ncontainers, Spring included, provide a mechanism for ensuring that all dependencies are defined when\r\nyou use Setter Injection, but by using Constructor Injection, you assert the requirement for the\r\ndependency in a container-agnostic manner.\r\nSetter Injection is useful in a variety of cases. If the component is exposing its dependencies to the\r\ncontainer but is happy to provide its own defaults, then Setter Injection is usually the best way to\r\naccomplish this. Another benefit of Setter Injection is that it allows dependencies to be declared on an\r\ninterface\r\n\r\n### Beanfactory / ApplicationContext\r\nIf your application needs only DI support, you can interact with the Spring DI container via the\r\nBeanFactory interface.\r\nApplicationContext interface is an extension to BeanFactory. In addition to DI services,\r\nthe ApplicationContext also provides other services, such as transaction and AOP service, message\r\nsource for internationalization (i18n), and application event handling, to name a few.\r\n\r\n### Spring Configuration Options (XML and Java Annotations)\r\nOne common approach nowadays is to define the application infrastructure (e.g., data source,\r\ntransaction manager, JMS connection factory, JMX, etc.) in XML file, while defining the DI configuration\r\n(injectable beans and beans’ dependencies) in annotations. \r\n\r\n\r\n### Using Method Injection\r\nLookup Method Injection\r\nLookup Method Injection was added to Spring since version 1.1 to overcome the problems encountered\r\nwhen a bean depends on another bean with a different life cycle—specifically, when a singleton depends\r\non a nonsingleton. In this situation, both Setter and Constructor Injection result in the singleton\r\nmaintaining a single instance of what should be a nonsingleton bean. In some cases, you will want to have\r\nthe singleton bean obtain a new instance of the nonsingleton every time it requires the bean in question\r\n\r\nTypically, you can achieve this by having the singleton bean implement the\r\nApplicationContextAware interface (we will discuss this interface in next chapter). Then, using the\r\nApplicationContext instance, the singleton bean can look up a new instance of the nonsingleton\r\ndependency every time it needs it. Lookup Method Injection allows the singleton bean to declare that it\r\nrequires a nonsingleton dependency and that it receive a new instance of the nonsingleton bean each\r\ntime it needs to interact with it, without needing to implement any Spring-specific interfaces.\r\nLookup Method Injection works by having your singleton declare a method, the lookup method,\r\nwhich returns an instance of the nonsingleton bean. When you obtain a reference to the singleton in\r\nyour application, you are actually receiving a reference to a dynamically created subclass on which\r\nSpring has implemented the lookup method. \r\n\r\n    public abstract class AbstractLookupDemoBean implements DemoBean {\r\n        public abstract MyHelper getMyHelper();\r\n        public void someOperation() {\r\n           getMyHelper().doSomethingHelpful();\r\n    }\r\n\r\n\r\nMethod Lookup Injection is intended for use when you want to work with two beans of different life\r\ncycles. Avoid the temptation to use Method Lookup Injection when the beans share the same life cycle,\r\nespecially if they are singletons.\r\n\r\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n        xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\">\r\n      <bean id=\"helper\" class=\"com.apress.prospring3.ch4.mi.MyHelper\" scope=\"prototype\"/>\r\n      <bean id=\"abstractLookupBean\" class=\"com.apress.prospring3.ch4.mi.AbstractLookupDemoBean\">\r\n      <lookup-method name=\"getMyHelper\" bean=\"helper\"/>\r\n      </bean>\r\n     <bean id=\"standardLookupBean\" class=\"com.apress.prospring3.ch4.mi.StandardLookupDemoBean\">\r\n         <property name=\"myHelper\">\r\n            <ref local=\"helper\"/>\r\n         </property>\r\n     </bean>\r\n\r\n\r\n\r\n### Choosing instantiation mode ==\r\n\r\nChoose singleton when :\r\n• Shared objects with no state: When you have an object that maintains no state and\r\n  has many dependent objects. Because you do not need synchronization if there is\r\n  no state, you do not really need to create a new instance of the bean each time a\r\n  dependent object needs to use it for some processing.\r\n• Shared object with read-only state: This is similar to the previous point, but you\r\n  have some read-only state. In this case, you still do not need synchronization, so\r\n  creating an instance to satisfy each request for the bean is just adding additional\r\n  overhead.\r\n• Shared object with shared state: If you have a bean that has state that must be\r\n  shared, then singleton is the ideal choice. In this case, ensure that your\r\n  synchronization for state writes is as granular as possible.\r\n• High throughput objects with writable state: If you have a bean that is used a great\r\n  deal in your application, then you may find that keeping a singleton and\r\n  synchronizing all write access to the bean state allows for better performance than\r\n  constantly creating hundreds of instances of the bean. When using this approach,\r\n  try to keep the synchronization as granular as possible without sacrificing\r\n  consistency. You will find that this approach is particularly useful when your\r\n  application creates a large number of instances over a long period of time, when\r\n  your shared object has only a small amount of writable state, or when the\r\n  instantiation of a new instance is expensive.\r\n\r\n  Other scopes :\r\n\r\n• Request: For web application use. When using Spring MVC for web application,\r\n   beans with request scope will be instantiated for every HTTP request and then\r\n  destroyed when the request is completed.\r\n• Session: For web application use. When using Spring MVC for web applications,\r\n   beans with session scope will be instantiated for every HTTP session and then\r\n  destroyed when the session is over.\r\n• Global session: For portlet-based web applications. The global session scope beans\r\n   can be shared among all portlets within the same Spring MVC–powered portal\r\n    application.\r\n• Thread: A new bean instance will be created by Spring when requested by a new\r\n   thread, while for the same thread, the same bean instance will be returned. Note\r\n  that this scope is not registered by default.\r\n\r\n\r\n### Different Modes of Autowiring\r\n\r\nSpring supports four modes for autowiring: byName, byType, constructor, default, and no (which is the\r\ndefault). \r\n- When using byName autowiring, Spring attempts to wire each property to a bean of the same\r\nname. So, if the target bean has a property named foo and a foo bean is defined in the\r\nApplicationContext, the foo bean is assigned to the foo property of the target.\r\n- When using byType autowiring, Spring attempts to wire each of the properties on the target bean\r\nautomatically using a bean of the same type in the ApplicationContext. So, if you have a property of type\r\nString on the target bean and a bean of type String in the ApplicationContext, then Spring wires the\r\nString bean to the target bean’s String property. If you have more than one bean of the same type, in\r\nthis case String, in the same ApplicationContext, then Spring is unable to decide which one to use for\r\nthe autowiring and throws an exception (of type\r\norg.springframework.beans.factory.NoSuchBeanDefinitionException).\r\n- The constructor autowiring mode functions just like byType wiring, except that it uses constructors\r\nrather than setters to perform the injection. Spring attempts to match the greatest numbers of arguments\r\nit can in the constructor. So, if your bean has two constructors, one that accepts a String and one that\r\naccepts a String and an Integer, and you have both a String and an Integer bean in your\r\nApplicationContext, Spring uses the two-argument constructor.\r\n- In default mode, Spring will choose between constructor and byType modes automatically. If your\r\nbean has a default (no-arguments) constructor, then Spring uses byType; otherwise, it uses constructor.\r\n\r\n###  Bean Life-Cycle Management\r\n\r\nIn general, two life-cycle events are particularly relevant to a bean: post-initialization and pre-destruction.\r\nIn the context of Spring, the post-initialization event is raised as soon as Spring finishes setting all\r\nthe property values on the bean and finishes any dependency checks that you configured it to perform.\r\nThe pre-destruction event is fired just before Spring destroys the bean instance. However, for beans with\r\nprototype scope, the pre-destruction event will not be fired by Spring. The design of Spring is that the\r\ninitialization life-cycle callback methods will be called on objects regardless of bean scope, while for\r\nbeans with prototype scope, the destruction life-cycle callback methods will not be called. Spring\r\nprovides three mechanisms a bean can use to hook into each of these events and perform some\r\nadditional processing: interface-based, method-based, and annotation-based mechanisms.\r\n\r\nUsing the interface-based mechanism, your bean implements an interface specific to the type of\r\nnotification it wants to receive, and Spring notifies the bean via a callback method defined in the\r\ninterface. For the method-based mechanism, Spring allows you to specify, in your ApplicationContext\r\nconfiguration, the name of a method to call when the bean is initialized and the name of a method to call\r\nwhen the bean is destroyed. For the annotation mechanism, you can use JSR-250 annotations to specify\r\nthe method that Spring should call after construction or before destruction.\r\n\r\nif you are coupling your application to Spring in other ways, using the interface method allows you to specify the callback \r\nonce and then forget about it. If you are defining a lot of beans of the same type that need to take advantage of the life-cycle notifications,then using the interface mechanism can avoid the need for specifying the life-cycle callback methods for\r\nevery bean in the XML configuration file. Using JSR-250 annotations is also another viable option, since it’s a standard defined by the JCP and you are also not coupled to Spring’s specific annotations. Just make sure that the IoC container you are running your application on supports the JSR-250 standard.\r\n\r\nOverall, the choice of which mechanism you use for receiving life-cycle notifications depends on\r\nyour application requirements. If you are concerned about portability or you are just defining one or two\r\nbeans of a particular type that need the callbacks, then use the method-based mechanism. If you use\r\nannotation-type configuration and certain that you are using an IoC container that supports JSR-250,\r\nthen use the annotation mechanism. If you are not too concerned about portability or you are defining\r\nmany beans of the same type that need the life-cycle notifications, then using the interface-based\r\nmechanism is the best way to ensure that your beans always receive the notifications they are expecting.\r\nIf you plan to use a bean across many different Spring projects, then you almost certainly want the\r\nfunctionality of that bean to be as self-contained as possible, so you should definitely use the interface-\r\nbased mechanism.\r\n\r\nPost Initilization methods :\r\n1.  Execute a Method When a Bean Is Created\r\n     <bean id=\"simpleBean1\"\r\n               class=\"com.apress.prospring3.ch5.lifecycle.SimpleBean\"\r\n               init-method=\"init\">\r\n            <property name=\"name\">\r\n                <value>Clarence Ho</value>\r\n           </property>\r\n           <property name=\"age\">\r\n                <value>100</value>\r\n          </property>\r\n2. Implementing the InitializingBean Interface\r\nThe InitializingBean interface defines a single method, afterPropertiesSet(), that serves the same purpose as the init() method.\r\n\r\n3. JSR250 @PostConstruct\r\n\r\n### Pre Destruction call backs\r\nThe destruction callback is an ideal mechanism for ensuring that your applications shut down\r\ngracefully and do not leave resources open or in an inconsistent state. However, you still have to decide\r\nwhether to use the destruction method callback, the DisposableBean interface, or the @PreDestroy\r\nannotation. Again, let the requirements of your application drive your decision in this respect; use the\r\nmethod callback where portability is an issue, and use the DisposableBean interface or a JSR-250\r\nannotation to reduce the amount of configuration required.\r\n\r\n###  BeanNameAware ApplicationContextAware\r\n\r\n###  FactoryBeans\r\nOne of the problems that you will face when using Spring is how to create and then inject dependencies\r\nthat cannot be created simply by using the new operator. To overcome this problem, Spring provides the\r\nFactoryBean interface that acts as an adaptor for objects that cannot be created and managed using the\r\nstandard Spring semantics. Typically, you use FactoryBeans to create beans that you cannot use the new\r\noperator to create such as those you access through static factory methods, although this is not always\r\nthe case. Simply put, a FactoryBean is a bean that acts as a factory for other beans. FactoryBeans are\r\nconfigured within your ApplicationContext like any normal bean, but when Spring uses the FactoryBean\r\ninterface to satisfy a dependency or lookup request, it does not return the FactoryBean; instead, it invokes\r\nthe FactoryBean.getObject() method and returns the result of that invocation.\r\n\r\n### Spring Profiles\r\nSpring’s profile feature lets us as application developers define the profiles by ourselves and activate\r\nthem either programmatically or by passing in the JVM argument. By using Spring’s profile support, you\r\ncan now use the same application archive and deploy to all different environments, by passing in the\r\ncorrect profiles as an argument during JVM startup. For example, you can have applications with\r\ndifferent profiles such as (dev, hibernate), (prd, jdbc), and so on, with each different combination\r\nrepresenting the running environment (development or production) and the data access library to use\r\n(Hibernate or JDBC). It brings application profile management into the programming side.\r\nBut this approach also has its drawbacks. For example, some may argue that putting all the\r\nconfiguration for different environments into application configuration files or Java classes and\r\nbundling them together will be error prone if not handled carefully (e.g., the administrator forgot to set\r\nthe correct JVM argument in their application server environment). Packing files for all profiles together\r\nwill also make the package a bit larger than usual. Again, let the application and configuration\r\nrequirements drive you to select the approach that best fits your project.\r\n\r\n###  PropertySource\r\n<context:property-placeholder> \r\n\r\n### Configuration  using JSR-330 annontations\r\n\r\nJEE 6 provides support for JSR-330 (Dependency Injection for Java), which is a collection of annotations for expressing an application’s DI configuration within a JEE container or other compatible IoC framework. Spring also supports and recognizes those annotations. Using JSR-330 annotations can help you ease the migration to the JEE 6 container or othercompatible IoC container (e.g., Google Guice) away from Spring.\r\n\r\n### AOP\r\n\r\nAOP is often referred to as a tool for implementing crosscutting concerns. When you “cut through” the unfamiliar\r\nterminology, you use AOP for modularizing individual pieces of logic, known as concerns, and you apply\r\nthese concerns to many parts of an application. Logging and security are typical examples of\r\ncrosscutting concerns that are present in many applications. Consider an application that logs the start\r\nand end of every method for debugging purposes. You will probably refactor the logging code into a\r\nspecial class, but you still have to call methods on that class twice per method in your application in\r\norder to perform the logging. Using AOP, you can simply specify that you want the methods on your\r\nlogging class to be invoked before and after each method call in your application.\r\n\r\nThere are two distinct types of AOP: static and dynamic. In static AOP,like that provided by AspectJ’s (http://eclipse.org/aspectj/) compile-time weaving mechanisms, the crosscutting logic is applied to your code at compile time, and you cannot change it without modifying the code and recompiling. With dynamic AOP,\r\nlike Spring AOP, crosscutting logic is applied dynamically, at runtime. This allows you to make changes in the distribution of crosscutting without recompiling the application. \r\n\r\n\r\n### AOP Concepts\r\n• Joinpoints: A joinpoint is a well-defined point during the execution of your\r\n   application. Typical examples of joinpoints include a call to a method, the Method\r\n  Invocation itself, class initialization, and object instantiation. Joinpoints are a core\r\n concept of AOP and define the points in your application at which you can insert\r\nadditional logic using AOP.\r\n• Advice: The code that is executed at a particular joinpoint is the advice. There are\r\n   many different types of advice, such as before, which executes before the\r\n  joinpoint, and after, which executes after it. In OOP, an advice comes in the form\r\n of a method within a class.\r\n• Pointcuts: A pointcut is a collection of joinpoints that you use to define when\r\n   advice should be executed. By creating pointcuts, you gain fine-grained control\r\n  over how you apply advice to the components in your application. As mentioned\r\n previously, a typical joinpoint is a Method Invocation. A typical pointcut is the\r\ncollection of all Method Invocations in a particular class. Often you can compose\r\npointcuts in complex relationships to further constrain when advice is executed.\r\n• Aspects: An aspect is the combination of advice and pointcuts. This combination\r\n   results in a definition of the logic that should be included in the application and\r\n  where it should execute.\r\n• Weaving: This is the process of actually inserting aspects into the application code\r\n   at the appropriate point. For compile-time AOP solutions, this is, unsurprisingly,\r\n  done at compile time, usually as an extra step in the build process. Likewise, for\r\n runtime AOP solutions, the weaving process is executed dynamically at runtime.\r\n\r\nAspectJ supports another weaving mechanism called load-time weaving (LTW), in\r\nwhich it intercepts the underlying JVM class loader and provides weaving to the\r\nbytecode when it is being loaded by the class loader.\r\n• Target: An object whose execution flow is modified by some AOP process is\r\n   referred to as the target object. Often you see the target object referred to as the\r\n  advised object.\r\n• Introduction: This is the process by which you can modify the structure of an\r\n   object by introducing additional methods or fields to it. You can use introduction\r\n  to make any object implement a specific interface without needing the object’s\r\n   class to implement that interface explicitly.\r\n\r\n### Types of AOP\r\n\r\nStatic AOP\r\nMany of the first AOP implementations were static. In static AOP, the weaving process forms another\r\nstep in the build process for an application. In Java terms, you achieve the weaving process in a static\r\nAOP implementation by modifying the actual bytecode of your application, changing and extending the\r\napplication code as necessary. Clearly, this is a well-performing way of achieving the weaving process\r\nbecause the end result is just Java bytecode, and you do not perform any special tricks at runtime to\r\ndetermine when advice should be executed.\r\nThe drawback of this mechanism is that any modifications you make to the aspects, even if you\r\nsimply want to add another joinpoint, require you to recompile the entire application\r\n\r\nDynamic AOP\r\nDynamic AOP implementations, like Spring AOP, differ from static AOP implementations in that the\r\nweaving process is performed dynamically at runtime. How this is achieved is implementation-\r\ndependent, but as you will see, Spring’s adopted approach is to create proxies for all advised objects,\r\nallowing for advice to be invoked as required. The slight drawback of dynamic AOP is that, typically, it\r\ndoes not perform as well as static AOP, but the performance is steadily increasing. The major benefit of\r\ndynamic AOP implementations is the ease with which you can modify the entire aspect set of an\r\napplication without needing to recompile the main application code\r\n\r\nInternally, Spring has two proxy implementations: the JDK dynamic proxy and the CGLIB proxy. By\r\ndefault, when the target object to be advised implements some sort of an interface, Spring will use a JDK\r\ndynamic proxy to create proxy instances of the target. However, when the advised target object doesn’t\r\nimplement an interface (e.g., it’s a concrete class), CGLIB will be used for proxy instance creation. One\r\nmajor reason is that JDK dynamic proxy only supports proxying of interfaces\r\n\r\nThe ProxyFactory class controls the weaving and proxy creation process in Spring AOP. Before you\r\ncan actually create a proxy, you must specify the advised or target object. You can do this, as you saw\r\nearlier, using the setTarget() method. Internally, ProxyFactory delegates the proxy creation process\r\nto an instance of DefaultAopProxyFactory, which in turn delegates to either Cglib2AopProxy or\r\nJdkDynamicAopProxy, depending on the settings of your application.\r\n\r\n###  Before Advice\r\n\r\n### After Advice\r\n\r\n### Around Advice\r\nAround advice functions like a combination of before and after advice, with one big difference—you can\r\nmodify the return value. Not only that, but you can prevent the method from actually executing. This\r\nmeans that using around advice, you can essentially replace the entire implementation of a method with\r\nnew code. Around advice in Spring is modeled as an interceptor using the MethodInterceptor interface.\r\nThere are many uses for around advice, and you will find that many features of Spring are created using\r\nmethod interceptors, such as the remote proxy support and the transaction management features.\r\nMethod interception is also a good mechanism for profiling the execution of your application\r\nuse MethodInterceptor\r\n\r\n### Point cuts\r\n\r\nProxyFactory.addAdvice() method is usedto configure advice for a proxy. this method delegates to addAdvisor() behind the scenes,\r\ncreating an instance of DefaultPointcutAdvisor and configuring it with a pointcut that points to all\r\nmethods. In this way, the advice is deemed to apply to all methods on the target. In some cases, such as\r\nwhen you are using AOP for logging purposes, this may be desirable, but in other cases you may want to\r\nlimit the methods to which an advice applies.\r\nOf course, you could simply perform the checking in the advice itself that the method being advised\r\nis the correct one, but this approach has several drawbacks. First, hard-coding the list of acceptable\r\nmethods into the advice reduces the advice’s reusability. By using pointcuts, you can configure the\r\nmethods to which an advice applies, without needing to put this code inside the advice; this clearly\r\nincreases the reuse value of the advice. The second and third drawbacks with hard-coding the list of\r\nmethods into the advice are performance related. To check the method being advised in the advice, you\r\nneed to perform the check each time any method on the target is invoked. This clearly reduces the\r\nperformance of your application. When you use pointcuts, the check is performed once for each\r\nmethod, and the results are cached for later use. The other performance-related drawback of not using\r\npointcuts to restrict the list-advised methods is that Spring can make optimizations for nonadvised\r\nmethods when creating a proxy, which results in faster invocations on nonadvised methods. These\r\noptimizations are covered in greater detail when we discuss proxies later in the chapter.\r\nWe strongly recommend that you avoid the temptation to hard-code method checks into your\r\nadvice and instead use pointcuts wherever possible to govern the applicability of advice to methods on\r\nthe target\r\n\r\nStatic pointcuts\r\nSpring calls the matches(Method, Class<T>) method of the MethodMatcher once\r\nfor every method on the target, caching the return value for subsequent invocations of those methods. In\r\nthis way, the check for method applicability is performed only once for each method, and subsequent\r\ninvocations of a method do not result in an invocation of matches().\r\n\r\nDynamic pointcuts\r\n\r\nSpring still performs a static check using matches(Method, Class<T>) the\r\nfirst time a method is invoked to determine the overall applicability of a method. However, in addition to\r\nthis and provided that the static check returned true, Spring performs a further check for each\r\ninvocation of a method using the matches(Method, Class<T>, Object[]) method. In this way, a dynamic\r\nMethodMatcher can determine whether a pointcut should apply based on a particular invocation of a\r\nmethod, not just on the method itself. \r\n\r\n### Understanding proxies\r\nThe core goal of a proxy is to intercept Method Invocations and, where necessary, execute chains\r\nof advice that apply to a particular method. The management and invocation of advice is largely proxy\r\nindependent and is managed by the Spring AOP framework. However, the proxy is responsible for\r\nintercepting calls to all methods and passing them as necessary to the AOP framework for the advice to\r\nbe applied.\r\nIn addition to this core functionality, the proxy must also support a set of additional features. It is\r\npossible to configure the proxy to expose itself via the AopContext class (which is an abstract class) so\r\nthat you can retrieve the proxy and invoke advised methods on the proxy from the target object. The\r\nproxy is responsible for ensuring that when this option is enabled via ProxyFactory.setExposeProxy(),\r\nthe proxy class is appropriately exposed. In addition to this, all proxy classes implement the Advised\r\ninterface by default, which allows for, among other things, the advice chain to be changed after the proxy\r\nhas been created. A proxy must also ensure that any methods that return this—that is, return the proxied\r\ntarget—do in fact return the proxy and not the target.\r\n\r\n### JDK Dynamic Proxy\r\n\r\nUnlike the CGLIB proxy, the JDK proxy can generate proxies only of interfaces, not classes. In this way, any object you want to proxy must implement at least one interface. In general, it is good design to use interfaces for your classes, but it is not always possible, especially when you are working with third-party or legacy code. In this case, you must use the CGLIB proxy.\r\nWhen you are using the JDK proxy, all method calls are intercepted by the JVM and routed to the\r\ninvoke() method of the proxy. This method then determines whether the method in question is advised\r\n(by the rules defined by the pointcut), and if so, it invokes the advice chain and then the method itself\r\nusing reflection. In addition to this, the invoke() method performs all the logic discussed in the\r\nprevious section.\r\nThe JDK proxy makes no determination between methods that are advised and unadvised until it is\r\nin the invoke() method. This means that for unadvised methods on the proxy, the invoke() method is\r\nstill called, all the checks are still performed, and the method is still invoked using reflection. Obviously,\r\nthis incurs runtime overhead each time the method is invoked, even though the proxy often performs no\r\nadditional processing other than to invoke the unadvised method via reflection.\r\n\r\n### Using CGLIB Proxies\r\nWith the JDK proxy, all decisions about how to handle a particular Method Invocation are handled at\r\nruntime each time the method is invoked. When you use CGLIB, CGLIB dynamically generates the\r\nbytecode for a new class on the fly for each proxy, reusing already generated classes wherever possible.\r\nWhen a CGLIB proxy is first created, CGLIB asks Spring how it wants to handle each method. This\r\nmeans that many of the decisions that are performed in each call to invoke() on the JDK proxy are\r\nperformed just once for the CGLIB proxy. Because CGLIB generates actual bytecode, there is also a lot\r\nmore flexibility in the way you can handle methods. For instance, the CGLIB proxy generates the\r\nappropriate bytecode to invoke any unadvised methods directly, reducing the overhead introduced by\r\nthe proxy. In addition to this, the CGLIB proxy determines whether it is possible for a method to return\r\nthis; if not, it allows the method call to be invoked directly, again reducing the runtime overhead.\r\n\r\n### Spring JDBC\r\n\r\n### DriverManagerDataSource\r\nYou can use Spring to manage the database connection for you by providing a bean that implements\r\njavax.sql.DataSource. The difference between a DataSource and a Connection is that a DataSource\r\nprovides and manages Connections.\r\nDriverManagerDataSource (under the package org.springframework.jdbc.datasource) is the simplest\r\nimplementation of a DataSource. By looking at the class name, you can guess that it simply calls the\r\nDriverManager to obtain a connection. The fact that DriverManagerDataSource doesn’t support database\r\nconnection pooling makes this class unsuitable for anything other than testing\r\n\r\nIn real-world applications, you can use Apache Commons BasicDataSource\r\n(http://commons.apache.org/dbcp/) or a DataSource implemented by a JEE application server (e.g.,\r\nJBoss, WebSphere, WebLogic, GlassFish, etc.), which may further increase the performance of the\r\napplication. \r\n\r\n### The JdbcTemplate Class\r\nThis class represents the core of Spring’s JDBC support. It can execute all types of SQL statements. In the\r\nmost simplistic view, you can classify the data definition and data manipulation statements. Data\r\ndefinition statements cover creating various database objects (tables, views, stored procedures, and so\r\non). Data manipulation statements manipulate the data and can be classified as select and update\r\nstatements. A select statement generally returns a set of rows; each row has the same set of columns. An\r\nupdate statement modifies the data in the database but does not return any results.\r\nThe JdbcTemplate class allows you to issue any type of SQL statement to the database and return any\r\ntype of result\r\n\r\n### NamedParameterJdbcTemplate\r\n    public class JdbcContactDao implements ContactDao, InitializingBean {\r\n       // Other methods omitted\r\n       public String findLastNameById(Long id) {\r\n       String sql = \"select last_name from contact where id = :contactId\";\r\n       SqlParameterSource namedParameters =\r\n                     new MapSqlParameterSource(\"contactId\", id);\r\n       return namedParameterJdbcTemplate.queryForObject(sql,\r\n                                                        namedParameters, String.class);\r\n    }  \r\n   }\r\n\r\n\r\n### Retrieving Domain Objects with RowMapper<T>\r\nRather than retrieving a single value, most of the time you will want to query one or more rows and then\r\ntransform each row into the corresponding domain object.\r\nSpring’s RowMapper<T> interface (under the package org.springframework.jdbc.core) provides a\r\nsimple way for you to perform mapping from a JDBC resultset to POJOs\r\n\r\n    public class JdbcContactDao implements ContactDao, InitializingBean {\r\n       // Other methods omitted\r\n       public List<Contact> findAll() {\r\n            String sql = \"select id, first_name, last_name, birth_date from contact\";\r\n                       return jdbcTemplate.query(sql, new ContactMapper());\r\n     }\r\n     private static final class ContactMapper implements RowMapper<Contact> {\r\n     public Contact mapRow(ResultSet rs, int rowNum) throws SQLException {\r\n            Contact contact = new Contact();\r\n            contact.setId(rs.getLong(\"id\"));\r\n            contact.setFirstName(rs.getString(\"first_name\"));\r\n            contact.setLastName(rs.getString(\"last_name\"));\r\n            contact.setBirthDate(rs.getDate(\"birth_date\"));\r\n            return contact;\r\n     }\r\n    }\r\n  }\r\n\r\n### Retrieving Nested Domain Objects with ResultSetExtractor\r\nLet’s proceed to a bit more complicated example, in which we need to retrieve the data from the parent\r\n(CONTACT) and child (CONTACT_TEL_DETAIL) table with a join and transform the data back into the nested\r\nobject (ContactTelDetail within Contact) accordingly.\r\nThe previously mentioned RowMapper<T> is suitable only for row base mapping to a single domain\r\nobject. For a more complicated object structure, we need to use the ResultSetExtractor interface. To\r\ndemonstrate its use, let’s add one more method, findAllWithDetail(), into the ContactDao interface. The\r\nmethod should populate the list of contacts with their telephone details.\r\n\r\n   // Import statements omitted\r\n   public class JdbcContactDao implements ContactDao, InitializingBean {\r\n       public List<Contact> findAllWithDetail() {\r\n           String sql = \"select c.id, c.first_name, c.last_name, c.birth_date\" +\r\n                        \", t.id as contact_tel_id, t.tel_type, t.tel_number from contact c \" +\r\n                        \"left join contact_tel_detail t on c.id = t.contact_id\";\r\n           return jdbcTemplate.query(sql, new ContactWithDetailExtractor());\r\n   }\r\n   \r\n   private static final class ContactWithDetailExtractor implements\r\n       ResultSetExtractor<List<Contact>> {\r\n       \r\n       public List<Contact> extractData(ResultSet rs) throws SQLException,\r\n         DataAccessException {\r\n            Map<Long, Contact> map = new HashMap<Long, Contact>();\r\n\r\nSpring Classes That Model JDBC Operations\r\nIn the preceding section, you saw how JdbcTemplate and the related data mapper utility classes had\r\ngreatly simplified the programming model in developing data access logic with JDBC. Built on top of\r\nJdbcTemplate, Spring also provides a number of useful classes that model JDBC data operations and let\r\ndevelopers maintain the query and transformation logic from resultset to domain objects in a more\r\nobject-oriented fashion. As mentioned, those class are packaged under\r\norg.springframework.jdbc.object. Specifically, we will discuss the following classes:\r\n\r\nMappingSqlQuery<T>: The MappingSqlQuery<T> class allows you to wrap the\r\nquery string together with the mapRow() method into a single class.\r\n\r\nSqlUpdate: The SqlUpdate class allows you to wrap any SQL update statement\r\ninto it. It also provides a lot of useful functions for you to bind SQL parameters,\r\nretrieve the RDBMS-generated key after a new record is inserted, and so on.\r\n\r\nBatchSqlUpdate: As the name implies, the class allows you to perform batch\r\nupdate operations. For example, you can loop through a Java List object and\r\nhave the BatchSqlUpdate queue up the records and submit the update\r\nstatements for you in a batch. You can set the batch size and flush the operation\r\nanytime as you want.\r\n\r\nSqlFunction<T>: The SqlFunction<T> class allows you to call stored functions in\r\nthe database with argument and return types.\r\n\r\n== Spring Hibernate Support == ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}