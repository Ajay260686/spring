{"name":"Spring Notes","tagline":"spring , spring jdbc , spring data, jpa , hibernate","body":"### Dependency Injection\r\nContext Dependency Lookup(CDL) v/s Dependency Injection\r\nThe Dependency Pull code must actively obtain a reference to the registry and interact with it to obtain the\r\ndependencies, and using CDL requires your classes to implement a specific interface and look up all\r\ndependencies manually. When you are using injection, the most your classes have to do is allow\r\ndependencies to be injected using either constructors or setters.\r\n\r\nUsing injection, you are free to use your classes completely decoupled from the IoC container that is\r\nsupplying dependent objects with their collaborators manually, whereas with lookup, your classes are\r\nalways dependent on the classes and interfaces defined by the container. Another drawback with lookup\r\nis that it becomes very difficult to test your classes in isolation from the container. Using injection,\r\ntesting your components is trivial, because you can simply provide the dependencies yourself using the\r\nappropriate constructor or setter.\r\n\r\nThe biggest reason to choose injection over lookup is that it makes your\r\nlife easier. You write substantially less code when you are using injection, and the code that you do write\r\nis simple and can, in general, be automated by a good IDE. You will notice that all of the code in the\r\ninjection samples is passive, in that it doesn’t actively try to accomplish a task. The most exciting thing\r\nyou see in injection code is objects getting stored in a field only; no other codes were involved in pulling\r\nthe dependency from any registry or container. Therefore, the code is much simpler and less error\r\nprone. Passive code is much simpler to maintain than active code, because there is very little that can go\r\nwrong.\r\n\r\n### Constructor v/s Setter Injection ==\r\nConstructor Injection is particularly useful when you\r\nabsolutely must have an instance of the dependency class before your component is used. Many\r\ncontainers, Spring included, provide a mechanism for ensuring that all dependencies are defined when\r\nyou use Setter Injection, but by using Constructor Injection, you assert the requirement for the\r\ndependency in a container-agnostic manner.\r\nSetter Injection is useful in a variety of cases. If the component is exposing its dependencies to the\r\ncontainer but is happy to provide its own defaults, then Setter Injection is usually the best way to\r\naccomplish this. Another benefit of Setter Injection is that it allows dependencies to be declared on an\r\ninterface\r\n\r\n### Beanfactory / ApplicationContext\r\nIf your application needs only DI support, you can interact with the Spring DI container via the\r\nBeanFactory interface.\r\nApplicationContext interface is an extension to BeanFactory. In addition to DI services,\r\nthe ApplicationContext also provides other services, such as transaction and AOP service, message\r\nsource for internationalization (i18n), and application event handling, to name a few.\r\n\r\n### Spring Configuration Options (XML and Java Annotations)\r\nOne common approach nowadays is to define the application infrastructure (e.g., data source,\r\ntransaction manager, JMS connection factory, JMX, etc.) in XML file, while defining the DI configuration\r\n(injectable beans and beans’ dependencies) in annotations. \r\n\r\n\r\n### Using Method Injection\r\nLookup Method Injection\r\nLookup Method Injection was added to Spring since version 1.1 to overcome the problems encountered\r\nwhen a bean depends on another bean with a different life cycle—specifically, when a singleton depends\r\non a nonsingleton. In this situation, both Setter and Constructor Injection result in the singleton\r\nmaintaining a single instance of what should be a nonsingleton bean. In some cases, you will want to have\r\nthe singleton bean obtain a new instance of the nonsingleton every time it requires the bean in question\r\n\r\nTypically, you can achieve this by having the singleton bean implement the\r\nApplicationContextAware interface (we will discuss this interface in next chapter). Then, using the\r\nApplicationContext instance, the singleton bean can look up a new instance of the nonsingleton\r\ndependency every time it needs it. Lookup Method Injection allows the singleton bean to declare that it\r\nrequires a nonsingleton dependency and that it receive a new instance of the nonsingleton bean each\r\ntime it needs to interact with it, without needing to implement any Spring-specific interfaces.\r\nLookup Method Injection works by having your singleton declare a method, the lookup method,\r\nwhich returns an instance of the nonsingleton bean. When you obtain a reference to the singleton in\r\nyour application, you are actually receiving a reference to a dynamically created subclass on which\r\nSpring has implemented the lookup method. \r\n\r\n    public abstract class AbstractLookupDemoBean implements DemoBean {\r\n        public abstract MyHelper getMyHelper();\r\n        public void someOperation() {\r\n           getMyHelper().doSomethingHelpful();\r\n    }\r\n\r\n\r\n    <beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n        xsi:schemaLocation=\"http://www.springframework.org/schema/beans\r\n       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd\">\r\n      <bean id=\"helper\" class=\"com.apress.prospring3.ch4.mi.MyHelper\" scope=\"prototype\"/>\r\n      <bean id=\"abstractLookupBean\" class=\"com.apress.prospring3.ch4.mi.AbstractLookupDemoBean\">\r\n      <lookup-method name=\"getMyHelper\" bean=\"helper\"/>\r\n      </bean>\r\n     <bean id=\"standardLookupBean\" class=\"com.apress.prospring3.ch4.mi.StandardLookupDemoBean\">\r\n         <property name=\"myHelper\">\r\n            <ref local=\"helper\"/>\r\n         </property>\r\n     </bean>\r\n\r\nMethod Lookup Injection is intended for use when you want to work with two beans of different life\r\ncycles. Avoid the temptation to use Method Lookup Injection when the beans share the same life cycle,\r\nespecially if they are singletons.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}